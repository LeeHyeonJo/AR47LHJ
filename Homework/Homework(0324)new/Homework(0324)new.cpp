// Homework(0330).cpp : 이 파일에는 'main' 함수가 포함됩니다. 거기서 프로그램 실행이 시작되고 종료됩니다.
// 0. 0324숙제: 봄버맨 게임 기본. 
// 화면(a)을 만들고 플레이어(*)를 띄운다. wsad에 반응해 상하좌우로 움직인다. 
// 조건1: *는 이동시 잔상을 남기지 않는다.
// 조건2: *은 화면을 넘어가지 않는다. 

#include <iostream>
#include <conio.h> // 이건 getchar() 때문에 
#include <Windows.h> // 이건 sleep()때문에 


int main()
{
    //1. 게임 화면을 만든다. 
    const int screenysize = 5; // 세로x2
    const int screenxsize = 5; // 가로x2 (이렇게 된 이유.. 외부for문이 세로y - 내부가 가로x라서) 

    char map[screenysize][screenxsize] = {}; // 그 다음 배열. 화면을 문자 a로 채울거니까 자료형은 char.
    // [] 안에는 상수가 들어가야 하는데, screenxsize는 상수가 아닌 변수이므로 들어갈 수 없음. 그래서 앞에 const를 붙여주게 된다. 
    // = {}; 배열 초기화임. 이거 반드시 해줘야 함. 

    // map[screenysize][screenxsize]는 게임화면(a)고 . 

//2. 화면을 a로 가득 채워준다. 어떻게 넣어주지?? 
    // 외우셈: 배열의 모든 요소를 한 번에 동일한 값으로 초기화할땐 for를 사용하는것이 일반적임. 
    // 1. 인덱스를 활용해 각각의 공간에 접근해서 값을 넣어주는법. 해보자. 
    /*map[0][0] = 'a';
    map[0][1] = 'b';
    map[1][1] = 'c';
    map[1][0] = 'd';*/

    // 2. for문으로 가득 채우기. (이게 일반적) 

    for (int y = 0; y < screenysize; y++) // >> 외부 반복문
        // y가 screenxsize(상수)를 초과하면 멈추는 반복문.
        // 초기식: x = 0, 조건식: x < screenxsize(=screenxsize가 x보다 커지면 종료), 증감식: x++   
    {
        for (int x = 0; x < screenysize; x++)     // >> 내부 반복문 (내부 반복문은 외부 반복문이 한번 반복할때마다 새롭게 실행된다)
            // 주의: 각 반복문을 제어하는 변수는 달라야 한다 (ex. x,y)
        {
            map[y][x] = 'a'; // 이중for문 반복하면서 0이었던 배열을 0,0에서 시작해서 5,5까지 a로 채워주는 과정 
            // 외부 반복문 1번 실행 -> 내부 반복문이 x 0~4까지 실행. 5에서 탈출. 
                    // 그 다음 외부 반복문 2번 실행 -> 다시 내부 반복문 0~4까지 실행. 이걸 외부 반복문의 y가 4가 될때까지 반복. 
        }
    };

    //3. a로 가득 채운 화면을 출력해준다. 
        // 주의! 한번에 배열을 짠~하고 띄운다기보다는.. 
        // printf_s의 출력 원리를 생각하셈. 배열에 들어간 요소를 하나씩 일일히 띄워주는 함수였음. 
        // 그러니까 이번에는 for문을 사용해서 화면에 띄워줄거임. (이 부분이 어려움) 

    for (int y = 0; y < screenysize; y++)
    {
        for (int x = 0; x < screenysize; x++)
            // 이중for문의 의미: x(가로)와 y(세로) 
            // 상수화된 변수 screensize의 값만큼..
            // 그러니까 레이저 인쇄처럼 한 행/열 씩 다다다다 인쇄해주는거임!!!. 
            // 그리고 이건 배열이 넣는 숫자에 따라서 바뀌니까 이렇게for문으로 배열을 구현할 수 밖에 없음!!  

        {
            printf_s("%c", map[y][x]);// 배열에a가 다 들어간 상태이므로. 문자형으로 배열에 들어간 a를 호출 
            /*9. %c : 하나의 문자로 출력 문자형
                 char c = 'a';
                 printf("%c", c);*/
        }
        printf_s("\n"); // (0,0) (1,0) (2,0) .... (4,4)까지 출력. 부등호인 이유는 0부터 시작하니까. 0~4면 다섯줄이지?

    }

    //4-1. 배열map에서 플레이어가 최초에 있을 위치를 지정한다. 
    int playery = screenysize / 2;  // 세로 위치  >> 외부 어쩌구 
    int playerx = screenxsize / 2;  // 가로 위치  >> 내부 어쩌구 
    map[playery][playerx] = '*'; // player y, x는 *의 위치임. 
    // (2,2)에 위치하는거 맞음. 근데 배열은 인덱스를 셀 때 0부터 세는거 잊지 말아야함. 
    // 따라서 실제 위치는 (일반적으로 생각하기에는 3,3), 배열적으로는 2,2에 위치하는게 맞음. 

//4-2. ***플레이어의 위치가 지정된 게임화면을 한번 지우고 다시 띄운다. (1차 헤멘 구간)*** 

    system("cls"); // a만 깔린 화면과 *가 같이 존재하는 상태. 화면을 싹 지워주고 이번엔 a가 들어간 버전으로 다시 띄워준다. (해결!! ㅜㅜ) 

    for (int y = 0; y < screenysize; y++)
    {
        for (int x = 0; x < screenysize; x++)


        {
            printf_s("%c", map[y][x]);

        }
        printf_s("\n");

    }

    //// 여기까지 화면&플레이어 초기 위치 띄우기 ////

    //5. wasd에 반응해서 플레이어가 움직이도록 한다. 
        // wasd를 눌렀을때, 라는 조건이 존재함. 키 입력 조건을 만족할"때마다" 1칸씩 움직여야함.
        // 이므로 if가 아니라 while을 써서 구현한다.(if는 조건이 만족되면 한 번만 실행 - while은 조건만족시 여러번실행) 
        // 키 입력은  키를 눌렀을 때만 화면이 멈추도록 해주는 함수가 있다. -> _kbhit() : 키를 눌렀다면 1 트루, 아니라면 0 펄스을 리턴하는 함수이고 정지하지 않는다. - 으로 구현한다. 

    while (true) // 5-1. 키를 눌렀을때. >> 무한반복된 이유: true라면 무한반복함. 
    {
        // 5-3. wasd 키 누를때 player가 이동하는 값까진 처리함.그 다음은 키를 눌렀을때마다 플레이어의 위치가 다시 나와야 함. 
        // 영사기와 비슷하게 생각하셈. 하단에는 움직이는 함수(프레임)까진 구현했지만, 이를 띄우려면 새로운 필름에 "재인쇄"를 해줘야하는거임. 즉...
        // 키를 누르면 이전의 화면을 삭제후, 키를 누른 이후의 값으로 다시 나오도록 구현하는게 맞음!! system("cls");  적재적소에 사용하는 법 익히기네 거의 뭐 ㅋㅋ 

        //6. 잔상 지우기 = *이 지나간 자리에 a를 다시 채워넣기 ** 여기도 중요했다. 
        //system("cls");  // 키를 누르지 않았다면 화면이 바뀌지 않아도 됨. 그러나 키를 누르면 화면이 바뀌어야 하므로 여기서 화면을 한번 지워줌 !!!!!! 
        //map[playery][playerx] = 'a'; // 이건 키를 누르기 이전의 player 위치. 거기에 a를 넣어서 잔상을 지움. 
        //system("cls");
                    // 포인트: 같은 위치에 a,*이 호출된 경우. 먼저 선언된 값이 우선. 이 경우 다시 지워줘야 새롭게 넣어준 값이 정상적으로 나온다는 것을 기억할것. 


        map[playery][playerx] = 'a';
        system("cls");

        // 허나 이건 진짜 화면만 지워준거임. 난 화면을 아직 띄워주지 않았다.. 5-1은 map에서 플레이어의 위치가 "어떻게" 이동할~지만 구현해둔 것. 
        // 이제 최하단에 5-1대로 재수정된 화면을 다시 한번 띄워줄거임. 


        // 5-1.우선 키가 눌렸을때를 if로 구현. 
        if (_kbhit()) // 이게 키가 눌린것을 확인. 얘는 내가 누른 키의 "값"을 받음. 그걸 단일문자로 다시 받아주는게 getch. 
            // 조건식으로는 _kbhit() - 키 누르면 0 이 아닌 값을 "버퍼"로 저장, 아니면 0 - 사용.
            // 버퍼란? 화면에 출력되기 전까지 임시적으로 입력한 값을 저장하는 메모리 공간. 
            // 버퍼에 입력된 키값을 _getch()로 받아야 한다. : 그냥 사용법이 이럼 외우셈. 
                //_getch()는 콘솔에서 "단일문자" ( = _kbhit()  에서 반환된, 사용자가 누른 키 값) 을 받음 
                // 요약: 사용자가 누른 키값을 getch()가 "한 글자" 읽어준 후 int로 반환해준다. 
        {
            char key = _getch();
            // wasd - 단일문자를 입력, 버퍼로 저장된 값을 getch()로 받아줄거임. 
            // 키를 누르고, 그 값을 _getch로 받은 뒤 변수 key에 저장한 상태. 

            //7. player*가 screen 화면을 벗어나지 않게 구현 
                // 하단의 playerx,y를 수정하는 과정이 배열의 인덱스를 직접 조작하는 과정임을 이해해야 함. 
                // 직접 조작하고 있으므로 *가 배열의 범위를 벗어나는 문제가 발생하는 것임. 
                // 뭔가 내 의도대로 바뀌는걸 원한다면 변수를 써야함. 변수를! 잊지말것. 

            // 문제 해결: *이 이동시, 좌표값을 업데이트하는 과정에서 배열의 범위를 벗어나는지 검사. 
            // 벗어나지 않을 경우에만 좌표값을 수정한다. (if 문으로 가능할듯) 
            // (x,y) = (0,0)~(5,5) 까지만 유효한 값임. 

        //5-2. wasd 눌릴때를 구현 >> 제어식의 결과에 따라 여러 경로중 하나를 선택할 수 있으므로(key값이 들어옴 -> 경로:> wasd 총 4개) =  스위치문 사용. 
            // map[playery][playerx] = '*'; >> 플레이어 * 이 위치한 좌표. 
            switch (key) // 스위치 문은 제어식의 값과 case 의 값을 비교한 후, 같은 값인 녀석을 case와 관련된 절들이 실행된다. 
            {
            case 'a': // 가로x가 좌측으로 이동 
            case 'A': // 대소문자 둘다 OK. case는 여러개 걸어줄 수 있음. 

                //7-1. *의 좌표값을 저장하는 playerx,y가 screen 배열의 범위를 벗어나는지 검사. 
                if (playerx > 0)
                {
                    playerx -= 1;
                }
                break; // 해당 case 문을 종료하고 switch문을 벗어난다. (대부분의 case문은 break문으로 끝나는 것을 기억할것) 
                // 사용자의 입력 키에 따라 break가 실행되면 switch문을 종료하고 다음 코드로 이동. 

            case 'd': // 가로x가 우측으로 이동 
            case 'D':
                if (playerx < screenxsize - 1) // 
                {
                    playerx += 1;
                }
                break;

            case 's': // 세로y가 상단으로 이동 
            case 'S':
                if (playery < screenysize - 1)
                {
                    playery += 1;
                }
                break;

            case 'w': // 세로y가 하단으로 이동 
            case 'W':
                if (playery > 0)
                {
                    playery -= 1;
                }
                break;


            } // 여기까지가 키가 눌린다면(if)  배열(플레이어) 의 값이 바뀐다는 뜻. (player* 출력 전) 

            // 5-4. wasd 키를 눌렀을때 변화한 player의 위치가 반영된 map을 재출력. 
            // 근데 왜 여기지?? >>  전제조건이 while-key를 눌렀을때니까. 이건 while문 안에 들어가는게 맞음. 

                    // 7-2. switch 문 안에 있던 map 배열 출력을 if문 하단으로 내림. 

            // 5-5. **2차 헤멤구간. if에서 구현한건 키가 눌렸을 경우, 배열map(플레이어)의 (x,y)에 들어갈 새로운 값임
            // 따라서 이 다음에는 배열map(플레이어)의 변경된 값(x,y)에 다시 *를 넣은 뒤, 출력해주어야함.
            // map[playery][playerx] = '*'; = 변경된 배열(플레이어) 에 *을 넣는다. 배열의 초기화. 

        } // if문 종료 

        // 5-6. 변경된 배열(플레이어)를 출력한다. 
        // 7-2. *의 좌표 변수값을 이용해 배열의 원소에 접근하는 방식으로 수정한 배열을 if문 아래로 배치
            // 생각해보니 당연함... 

        map[playery][playerx] = '*';


        for (int y = 0; y < screenysize; y++)
        {
            for (int x = 0; x < screenysize; x++)


            {
                printf_s("%c", map[y][x]);

            }
            printf_s("\n");

        }

        //5-5. 눈 반짝임이 너무 심하므로 sleep 함수 사용.  
        Sleep(500);

    }
};
