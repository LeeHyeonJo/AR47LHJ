// 051_DeleteHeap.cpp : 이 파일에는 'main' 함수가 포함됩니다. 거기서 프로그램 실행이 시작되고 종료됩니다.
// deleteheap 할때의 주의사항. (delete는 이전에 할당된 메모리를 해제하는 것.)
// 메모리 할당 연산자 'new'는 항상 포인터 변수를 통해 할당된 메모리의 주소를 반환함. 
// new연산자는 동적으로 메모리를 할당하고, 할당된 메모리의 "시작 주소"를 반환하기 때문임. 

// 이때 new 연산자가 반환하는 건 메모리의 시작주소를 나타내는 포인터 변수임. 따라서 new 연산자의 결과를 변수에 할당하기 위해서는 포인터 변수를 사용해야 함. 
// -->>항상 반환된 메모리의 시작주소를 가리키는 포인터 변수를 사용해야함에 주의!! (new를 사용하고, 포인터 변수로 시작주소값을 받아주라는 의미) 

#include <iostream> // crtdbg.h가 들어있다.

void MyDelete(int* Ptr)
{
    // 지운다.
    delete Ptr;
    Ptr = nullptr;
}

void MyValueZero(int Value)
{
    Value = 0;
}

void MyValueTest(int& Value)
{
    Value = 0;
}

void main()
{
    int Test = 100;
    MyValueZero(Test);

    // 외우셔야 합니다.
    // 윈도우 전용 삭제하지 않은 힙 메모리 출력에 표시. 
    _CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF);

    // ::operator delete();

    int* NewInt = nullptr;

    if (nullptr == NewInt)
    {
        return;
    }

    MyValueTest(*NewInt);

    // 1. 중복할당하면 안된다. 

    {//1. 첫번째 설명. 
        int* Newint = new int(); //0으로 초기화된 int변수 1개 생성 (딱히 이름 붙이진 않음)
        //메모리(힙) 할당 연산자 'new'를 사용해 새로운 int변수(int())를 동적으로 할당한다. 
        //이때 Newint 포인터 변수는 int변수의 메모리 주소(ex.500)를 가리킨다. 

        Newint = new int(); //0으로 초기화된 또 다른 int변수 1개 생성 (얘도 딱히 이름을 붙이진 않음) 
        // 다시 new를 사용해 다른 메모리 공간에 새로운 int변수(int())를 할당하려고 한다.
        // 먼젓번에 선언한 Newint는 포인터 변수였으므로, 자연스럽게 새로운 int변수의 메모리 주소(ex.600)을 가리키게 된다. 
        // 따라서 Newint 변수는 새롭게 할당된 공간의 주소를 가리키게 된다. (600)
        // -> 이래서 500의 주솟값을 갖고있던 int변수(구버전)은 "잃어버리게" 된다. 이를 메모리 누수라고 한다. 


        // <변수를 이름 없이 함수형태로 선언하는게 가능한가?> 
        // int(); 이 형태로 선언된 것은 변수가 아니라 함수다(근데 매개변수가없는)! 즉, 디폴트 생성자라고 부른다. 
        // 의미: 함수 선언의 일부분. 위의 경우는 매개변수가 없는 "int" 자료형을 반환하는 함수를 선언한 것. 
        // 사용처: 디폴트 생성자는 "선언한 자료형" 의 변수를 초기화하는데 사용할 수 있다. 위의 예시로는 "int" 자료형 변수를 초기화하는데 사용된다. 

        // <<디폴트 생성자란?>>
        // 의미: 클래스에서 생성자를 정의 하지 않았을때, 컴파일러가 자동으로 생성해주는 생성자 함수. 
        // 이때, 디폴트 생성자는 매개변수를 가지지 않으며, 클래스의 멤버변수를 기본값으로 초기화해준다. 
        // 양식: 클래스 이름(); 
        // 주의점: 클래스의 멤버 변수중 초기값을 가지지 않는 변수가 있다면, 사용자가 직접 디폴트 생성자를 정의해 모든 멤버변수를 초기화해주어야 한다. 
        // ㄴ 사유: 초기값을 가지지 않는 변수가 있으면 디폴트 생성자에서 해당 변수를 직접 초기화해주지 않기 때문. 
        // 그외: 상속을 사용할때도 디폴트 생성자는 중요하다. 기본 클래스에 디폴트 생성자가 없다면, 파생 클래스에서 생성자를 정의할 때.
        // 반드시 기본 클래스의 생성자를 호출해야 한다. 이때 디폴트 생성자가 존재하지 않으면, 파생 클래스에서 생성자를 정의할 때 기본 클래스의 생성자를
        // 호출할 수 없으므로 오류가 발생한다. 

        // <<int* Newint = new int(); 중, 디폴트 생성자 new int();에 대하여>> 
        // 이해한것: int();는 디폴트 생성자. 기본값이 0으로 초기화된 int형 변수를 생성한다. 
        // 이 코드에선 int 형 변수가 직접적으로 선언된 건 아님!! 그리고 new 연산자가 호출하는 생성자 함수는,  생성하려는 객체의 자료형에 따라 결정됨. (ok)
        // 따라서 int* Newint = new int(); 코드에서 Newint 포인터 변수는, 0으로 초기화된 int형 변수가 저장된 메모리 블록을 가리키게 됨. 
        // 이때 new 는 으로 초기화된 int형 변수가 저장된 메모리 블록의 시작 주소값을 반환한다. 

        // 근데 이런경우는 값을 확인하기 애매해지므로, 생성자는 제대로 호출해주는게 좋다. 
        // 나중에 뒤에서 new int(10); 으로 제대로 호출해주었음. 

        delete Newint;
    }

    // 위의 예시를 알맞게 고치려면? 
    // 한번 할당한건(new) 지우고(delete/이전에 할당된 메모리를 해제) 다시 받아서 사용하면 된다.
    {
        int* Newint = new int();
        delete Newint; // 꼭 Newint를 다시 빨아써야겠다면
        Newint = new int();
        delete Newint;
    }

   // 2. null 값이 나오지 않게 방어하기. >> null 체크라고 함. 포인터는 반드시 null을 체크하고 사용해야 한다. 
    {
        // new는 운영체제한테 부탁해서 동적 메모리를 할당하는 자료형임. 
        // 어떤 일이 있었건 운영체제가 할당 못하면 null값을 리턴한다. (ex. 메모리를 다 썼다던가.. heap이 한계에 도달) 
        int* Newint = new int();

        //  null 체크하는 습관을 반드시 들일 것. (가장 중요함) 
        if (nullptr == Newint) // 의미: 만약 포인트 변수 Newint가 null을 가리키고 있다면? 
        {
            return; //  그대로 리턴해주라는 뜻 (안돼 돌아가 라는 의미) 
        }
        *Newint = 20; // 포인트 변수 Newint가 null을 가리키고 있지 않다면, 포인트 변수 Newint(= 주솟값)가 가리키는 메모리의 값에 20을 대입하라. 

        delete Newint; // 한번 사용했으므로 leak이 발생하지 않게 지워주시오. 
    }

    // 3. 댕글링 포인터: 지운 메모리를 또 지우는 것
         {
             int* Newint = new int();
             delete Newint;
             delete Newint;
         }  //-> 메모리 크러쉬 발생. 

    // 따라서, 한번 지운 모든 포인터는 그 다음에 null값을 대입해주는게 기본임. (도구 사용한 뒤에 수납장에 차곡차곡 넣어주는 느낌) 
    // 이것을 "안전한 삭제(세이브 델리트)" 라고 함. 


    {
        int Value = int(10); //int 생성자를 호출했는데, int(); 이렇게 하면 아무값이나 나오므로, 제대로 호출해주는것이 좋음. 

        int* Newint = new int(10); 

        // 안전한 삭제(세이브 델리트)의 예시 
        if (nullptr != Newint) // Newint가 Null이 아니라면 -> a~c의 순서에 따라 Newint를 delete 해주고, null을 넣어 깔끔하게 청소해준다. (null이면 이걸 할 이유가없고) 
        {
            delete Newint;    // a.포인터 변수 Newint를 delete함(지우다, 이전에 할당된 메모리를 해제하다) -> 아래 Newint에 알수 없는 값이 들어가는 걸 확인할 수 있다. 
            Newint = nullptr; // b.알 수없는 값을 받은 Newint에 nullptr를 할당하다.
                              //c. null을 받자 포인터 변수 Newint는 000000000 이라는 아주 깔끔한 메모리 주소를 받게 되다. 
        }

       

        // delete 시 주의할 점 하나더 
        if (nullptr != Newint)
        {
            delete Newint; //  ㄱ.delete 는 포인터 변수 Newint에 할당된 메모리를 해제하는 역할'만' 있음. nullptr이 자동으로 들어가지 않는다. 
            Newint = nullptr; // ㄴ. 또한, delete한다고 해서 포인터 변수 Newint에 할당 '되었던' 메모리 주소가 삭제되는게 아님!!! 


            // delete는 operator delete(); 호출과 동일하다 

            // operator이란? 영상 15분 15초까지 봄. 이따 일어나서 나머지 해야지. 0405

        }

    }


    {
        int* NewPtr = new int();

        if (nullptr != NewPtr)
        {
            operator delete(NewPtr);
            NewPtr = nullptr;
        }

        // MyDelete(NewPtr);
    }
}
