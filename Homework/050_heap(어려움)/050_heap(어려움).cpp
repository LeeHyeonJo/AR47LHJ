// 050_heap.cpp : 이 파일에는 'main' 함수가 포함됩니다. 거기서 프로그램 실행이 시작되고 종료됩니다.
// 어려운 개념이므로 주의.  doc 메모리 영역에 대한거 복습 
// 힙영역, 자료형 new& delete 뉴와 델리트는 항상 함께간다. 

#include <iostream>
#include <crtdbg.h>

// 힙영역: 동적 메모리가 들어간다. 

class Monster
{

};

int main()
{
    // 아래까지 보고 다시 위로 올라오다. 
    // 아래 코드는 외우셈. 메모리 출력 여부를 출력서 볼 수 있게 해주는 것. 

    _CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF);
    // 힙 쓸때 위에꺼 코드 꼭 메인에 쳐놓고 leak이 있는지 없는지 확인할것.


    Monster* PtrMonster = new Monster();

    while (true)
    {

    }

    // 강제 종료의 경우에는 어쩔수없이 릭이 남을수 있지만 
    delete PtrMonster;

    // - -------------------------------------------- - // 

    // 연산자   자로형  생성자 
    // new     자료형      ();
    new int(); // > 힙 영역에 int 메모리를 하나 만듬 
    // 의미: 힙에 만들어진 특정 번지의 메모리, 즉 주소값만을 줌. (int 대신 다른거 넣어도 됨. monster.등. 저 자리는 메모리의 이름임)

    new int(); // 따라서 위에껀 잃어버린 힙. 만들어진 건 맞는데, 그 주소값을 받아줄 메모리가 없음.. 따라서 사용불가

    int* Ptr = /*operator new() 이게 오리지널임 줄인게 new int*/new int();
    // 따라서 힙에 생성된 int의 주소를 반드시 이렇게 받아줘야한 사용할 수 있게 됨. 

    *Ptr = 20; // 이게 힙의 메모리를 사용한 것. (Ptr이 int의 주소값이고, 거기에 *하나 더 달았으니 int 그 자체가 됨) 

    // 그런데!! 힙은 스스로 지워지지 않음. 
    delete Ptr; // 이렇게 선언해야 힙을 지울 수 있다.
    // 따라서, 게임이 느려지지 않도록 힙은 사용 후 반드시 지워줘야 한다. 

    // 힙영역을 할당하고 지우지 않는 것을 Leak, 메모리 누수라고 부른다.


    // 그러나!! 주솟값을 받지 않은 힙은 절대로 지울 수 없다. (23줄의 그것) 

            // 결론: 힙은 주소값을 반드시 받아야 하므로, "포인터"로 사용할 수 밖에 없다. 
            // NEW 연산자 -> 힙에 할당된 메모리의 주소를 ... ... 암튼 주소임..!! 그걸 포인터로 받아줘야함!! 
    

    // 그럼 힙은 언제 쓰는가? 
    // 힙의 특징: 내가 필요한 만큼 메모리를 막 만들 수 있음
    // 따라서 내가 갯수를 예상할 수 없는 몬스터, 총알이 적합함. 

    // ----------------------------------------------------------- // 

    // 힙의 특징: 가장 자유롭게 메모리를 할당할 수 있는 영역이다. 
    // 내가 원하는 만큼 윈도우에게 허락을 받고 늘릴 수 잇음 (아래 예시) 
    // ex)while로 new int를 선언하면 .. 힙에 무한하게 int가 생성생성.

}
