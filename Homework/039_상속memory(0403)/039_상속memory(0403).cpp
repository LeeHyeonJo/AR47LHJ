// 039_상속memory(0403).cpp : 이 파일에는 'main' 함수가 포함됩니다. 거기서 프로그램 실행이 시작되고 종료됩니다.
// 상속 메모리에 대해서 설명 
// 생성자와 소멸자. 소멸자 함부로 호출 금지 !!!!!!!!!!!!!!!!! 

#include <iostream>

class A // 부모 클래스 
{
public: 
    __int64 Test;

public:
    // 생성자 
    A()
        : Test(10) // 2. 멤버이니셜라이저 문법: 멤버변수의 메모리 생성이 이 과정에서 됨. ( = 클래스의 멤.변의 초기화) 
        // 초기화 메모리가 만들어지는 순간에 값을 입력됨. 
    {
        printf_s("A 생성자\n");
    }

    // 소멸자 - 하단에 설명할거임. 
    ~A()
    {
        printf_s("A 소멸자\n");
    }
};

// 자식클래스 - class A를 상속중 
class B : public A //1. 상속 받은 경우, 자식 클래스에는 A클래스에서 선언한 메모리까지 함께 들어가게 된다. 
{
public:
    // __int64 Test; // 이런식으로!! 
    char Value;
    B()
        :A() , Value('a') // B()를 초기화 -> 부모클래스 A() 생성자 호출, Value 멤버 변수 초기화 
    {
        Test = 10; // <- 이때, 자식 클래스는 부모 클래스의 멤.변을 "사용"만 가능함. 변경은 불가능 (대입x라는 의미)  
        // ㄴ 따라서 이건 컴파일러가 무시하고 지나간다. 
        printf_s("B 생성자 \n"); 
        
    }
    // 소멸자: 메모리가 "지워짐" 을 의미함. 
    // ㄴ 그러나 호출한다고 해서 메모리가 진짜 지워진건 아님. "메모리에서 존재하지 않는 취급" 이란 약속임. 
    // 소멸자의 특징: 인자를 넣어줄 수 없다. (~A () <- 이 괄호 안에 아무것도 안 들어감 ) 
    // 소멸자 선언 방법 : ~클래스 이름() . 이 형태 이외는 인정x
    // ** 소멸자의 생성/소멸 순서 ** : 생성은 부모 -> 자식. 소멸은 자식 -> 부모. 
    ~B()
    {
        Test = 20;
        printf_s("B 소멸자\n");
    }


};

// main 에 선언을 해야 메모리들이 값을 갖는 것을 항상 잊지 말것. 

int main()
{
    B newB = B(); // 생성자로 오브젝트를 초기화해줌

    // 소멸자 호출하는 법 //
    // newB. ~B();  <- 근데 이거 잘 안씀!! 

    int Value = sizeof(B);
 
}

